# CAPFAST to EPICS Database Makefile.
# Makefile.one - generated for Hac_DYNPWR by mkNewapp script
# - This file supports both R3.12 and R3.13

# Don't fill in the first 3, they are passed in
APP	   =
IOC	   =
FILENM     =
# Modify next line to match your database names if different from $FILENM
FILE       = $(FILENM)
VxFILE     = startup.$(APP)*$(IOC)
SERVER     = $(shell whichServer ioc$(IOC))
PROD_DIR   = ../prod_dir_$(SERVER)
InstallDir = $(PROD_DIR)/db
VxInstallDir = $(PROD_DIR)/vxcmd
RuleFile   = $(FILE).rules
TokenFile  = $(FILE).tokens
AddrFile   = $(FILE).address
HwListFile = $(FILE).hwiolist

DBDIR 	   = ../db
EDF        = ../db/edif
SR         = ../db/sr
DATABASE   = ../db/database
ifeq ($(shell whichEpicsVer), R313)
DBFILE     = $(DATABASE)/$(FILE).db
VxDir      = ../vxcmd/R313
else
DBFILE     = $(DATABASE)/$(FILE).database
VxDir      = ../vxcmd
endif

# if schematic file/ epics database design of your application is same
# for all the IOCs, except the record names, you should define 
# EDFFILE as $(EDF)/$(APP).edf and resolving record names 
# during the conversion step: sr -> sf
EDFFILE    = $(EDF)/$(FILE).edf

SCH2EDF	   = sch2edif
EDIF_FLAGS = -n
EDB_FILE   = $(EPICS)/capfast/edb.def
LOC_EDB_FILE   = ./edb.def.local
# To use cutsom record support (where the record is not in the
# common edb.def file), customize and uncomment the following
# line.  Below, a new edb.def, called edb.def.local, will be
# created for use in the make.  Do not cvs this file.
# CUST_EDB += ../../../<recapp>/<ver>/src/edb.def
MAKE_EDB   = make_edb
CUST_EDB  +=
EDIF2SR    = edif2sr
SR2SF      = sr2sf
ifeq ($(shell whichEpicsVer),R313)
SF2DB      = sf2db
else
ATDB       = atdb
endif
SF2HW      = sf2hw
# Comment out above line and uncomment this line if 
# using your own sf2hw.config file
#SF2HW  = sf2hw -c ./sf2hw.config
DCTSDR     = default.dctsdr

# CAPFAST Schematic File Dependencies
# These header files require FILE as input, and return
# SCH_OBJS as output.  If the header file does not exist,
# then it will be created and another make will be issued.
SHELL = /bin/sh
dependsC = mkDepends
dependsF = $(FILE).depends

# First time flag.  For first call to this makefile, do not pass this
# flag.  When a dependency file has to be created, this flag will be
# passed with a # value of NO, which over-writes this YES value.
# This will eliminate any infinite loop recursions.
FIRST = YES

SCH_OBJS   = 
dependsExist := $(shell test -r $(dependsF) || echo NO)
ifneq ($(dependsExist),NO)
include $(dependsF)
endif


#+++++++++
ifeq ($(dependsExist),NO)   # Check for a missing .depends file.
#+++++++++


# The .depends file is missing.  Create this file (via the "depends"
# dependency for the following "all:").  Then re-issue the original
# make request.  A new make will be executed, but this time with
# an existing (just made) .depends file.  If the .depends file cannot
# be created, then this make file will not try to make the .depends
# file again (this will eliminate the infinte recursion loop).

#---------
ifeq ($(FIRST),YES)  # Check for first time, to stop infinite recursion loop.
#---------

.PHONY:	all
all:	depends                             # Create the .depends file.
	$(MAKE) -f ./Makefile.one FIRST=NO  # Re-issue the make command.

#---------
else
#---------

.PHONY:	all
all:
	@echo "Makefile.db:  $(APP) ERROR  Stop .depends infinte recursion."

#---------
endif
#---------

# Ignore the database creation section of this makefile, but keep
# the clean, install and depends sections.


#+++++++++
else
#+++++++++

all:		$(DBFILE) 

$(EDFFILE):	$(SCH_OBJS)
		$(SCH2EDF) $(EDIF_FLAGS) $(FILE).sch
		@test -d $(DBDIR) || mkdir $(DBDIR)
		@test -d $(EDF) || mkdir $(EDF)
		rm -f $@
		mv $(FILE).edf $(EDFFILE)

$(SR)/$(FILE).sr: 	$(EDFFILE)
			rm -f $@
			$(MAKE_EDB) $(EDB_FILE) $(CUST_EDB)
			$(EDIF2SR) $(EDFFILE) $(LOC_EDB_FILE) $(SR)/$(FILE).sr > $(FILE).log
			sed -e 's/.SVAL/.VAL/' $(SR)/$(FILE).sr > $(SR)/$(FILE).srx
			mv $(SR)/$(FILE).srx $(SR)/$(FILE).sr

$(SR)/$(FILE).sf: 	$(SR)/$(FILE).sr $(RuleFile) $(TokenFile)
			rm -f $@
			$(SR2SF) -s -l $(RuleFile) -t $(TokenFile) < $(SR)/$(FILE).sr > $@

$(HwListFile):  	$(AddrFile)
			rm -f $@
			awk ' {print $$1} ' $(AddrFile) > $@

$(SR)/$(FILE).hw: 	$(SR)/$(FILE).sf $(AddrFile) $(HwListFile)
			rm -f $@
			$(SF2HW) -u -l $(HwListFile) -a $(AddrFile) -f $(SR)/$(FILE).sf

$(DBFILE): 		$(SR)/$(FILE).hw
			@test -d $(DATABASE) || mkdir $(DATABASE)
			rm -f $(DBFILE)
ifeq ($(shell whichEpicsVer), R313)
			$(SF2DB) $(FILE)  <  $<  >  $@
else
			$(ATDB) $(DCTSDR) $(DBFILE) < $<
endif

#+++++++++
endif
#+++++++++

.PHONY: clean
clean:
	rm -f $(DBFILE)
	rm -f $(SR)/$(FILE).sf
	rm -f $(SR)/$(FILE).sr
	rm -f $(SR)/$(FILE).hw
	rm -f $(EDFFILE)
	rm -f $(EDB_FILE).local
	rm -f *.log
	rm -f $(DATABASE)/$(FILE).database
	rm -f $(dependsF)

.PHONY: install
install:
ifeq ($(shell whichEpicsVer), R313)
	@echo INSTALL $(FILE)*.db into $(InstallDir)
	@test -d $(PROD_DIR)/db || mkdir $(PROD_DIR)/db
	@test -d $(InstallDir) || mkdir $(InstallDir)
	rm -f $(InstallDir)/$(FILE).db
	cp $(DATABASE)/$(FILE).db  $(InstallDir)
else
	@echo INSTALL $(FILE)*.database into $(InstallDir)
	@test -d $(PROD_DIR)/db || mkdir $(PROD_DIR)/db
	@test -d $(InstallDir) || mkdir $(InstallDir)
	rm -f $(InstallDir)/$(FILE).database
	cp $(DATABASE)/$(FILE).database $(InstallDir)
endif
	@echo INSTALL $(VxFILE) into $(VxInstallDir)
	@test -d $(VxInstallDir) || mkdir $(VxInstallDir)
	rm -f $(VxInstallDir)/$(VxFILE)
	cp $(VxDir)/$(VxFILE)  $(VxInstallDir)

.PHONY:	depends
depends:
	@echo "\n---------- DEPENDS $(FILE) DATABASE ----------"
	@echo "MAKE = <$(MAKE)>"
	rm -f $(dependsF)
	$(dependsC) $(FILE).sch ./schPaths

.PHONY:	status
status:
	@test ! -r $(FILE).depends \
	    || (echo 'WORK: \c'; ls -l $(dependsF))
###########
# For 3.13
###########
ifeq ($(shell whichEpicsVer),R313)
	@cd $(DATABASE); test ! -r $(FILE).db \
	    || (echo 'WORK: \c'; ls -l $(FILE).db)
	@cd $(InstallDir); test ! -r $(FILE).db \
	    || (echo 'DEV:  \c'; ls -l $(FILE).db)
else
	@cd $(DATABASE); test ! -r $(FILE).database \
	    || (echo 'WORK: \c'; ls -l $(FILE).database)
	@cd $(InstallDir); test ! -r $(FILE).database \
	    || (echo 'DEV:  \c'; ls -l $(FILE).database)
endif
##########


